!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AGAIN_MAX_TIMES	requestData.h	/^const int AGAIN_MAX_TIMES = 200;$/;"	v
ANALYSIS_ERROR	requestData.h	/^const int ANALYSIS_ERROR = -2;$/;"	v
ANALYSIS_SUCCESS	requestData.h	/^const int ANALYSIS_SUCCESS = 0;$/;"	v
CC	makefile	/^CC=g++$/;"	m
Epoll	epoll.h	/^class Epoll{$/;"	c
HTTP_10	requestData.h	/^const int HTTP_10 = 1;$/;"	v
HTTP_11	requestData.h	/^const int HTTP_11 = 2;$/;"	v
HTTPversion	requestData.h	/^    int HTTPversion;$/;"	m	class:RequestData
HeaderState	requestData.h	/^enum HeaderState{$/;"	g
KEEPALIVE	requestData.h	/^const int KEEPALIVE = 5*60*1000;$/;"	v
MAXEVENTNUM	main.cpp	/^extern const int MAXEVENTNUM=5000;\/\/use in epoll_events[]$/;"	v
MAXFDNUMS	main.cpp	/^extern const int MAXFDNUMS=1024;\/\/use in fd2reqdata[]$/;"	v
MAXLISTENQUEUE	main.cpp	/^extern const int MAXLISTENQUEUE=1024;\/\/use in listen()$/;"	v
MAX_BUFF	requestData.h	/^const int MAX_BUFF = 4096;$/;"	v
MAX_BUFF	utils.cpp	/^const int MAX_BUFF=4096;$/;"	v
MAX_QUEUE	threadpool.h	/^const int MAX_QUEUE = 65535;$/;"	v
MAX_THREADS	threadpool.h	/^const int MAX_THREADS =16;$/;"	v
METHOD_GET	requestData.h	/^const int METHOD_GET = 2;$/;"	v
METHOD_POST	requestData.h	/^const int METHOD_POST = 1;$/;"	v
MimeType	requestData.h	/^class MimeType{$/;"	c
MutexLock	MutexLock.h	/^    MutexLock(){$/;"	f	class:MutexLock
MutexLock	MutexLock.h	/^class MutexLock:noncopyable{$/;"	c
MyHandler	threadpool.cpp	/^void MyHandler(std::shared_ptr<void> req)$/;"	f
PARSE_HEADER_AGAIN	requestData.h	/^const int PARSE_HEADER_AGAIN = -1;$/;"	v
PARSE_HEADER_ERROR	requestData.h	/^const int PARSE_HEADER_ERROR = -2;$/;"	v
PARSE_HEADER_SUCCESS	requestData.h	/^const int PARSE_HEADER_SUCCESS = 0;$/;"	v
PARSE_URI_AGAIN	requestData.h	/^const int PARSE_URI_AGAIN = -1;$/;"	v
PARSE_URI_ERROR	requestData.h	/^const int PARSE_URI_ERROR = -2;$/;"	v
PARSE_URI_SUCCESS	requestData.h	/^const int PARSE_URI_SUCCESS = 0;$/;"	v
PATH	main.cpp	/^extern const std::string PATH="\/";\/\/root path$/;"	v
PORT	main.cpp	/^const int PORT=5678;$/;"	v
RequestData	requestData.cpp	/^RequestData::RequestData():$/;"	f	class:RequestData
RequestData	requestData.cpp	/^RequestData::RequestData(int _epollfd, int _fd, std::string _path):$/;"	f	class:RequestData
RequestData	requestData.h	/^class RequestData:public std::enable_shared_from_this<RequestData>{$/;"	c
SP_ReqData	timer.h	/^    typedef std::shared_ptr<RequestData> SP_ReqData;$/;"	t	class:TimerManager
SP_ReqData	timer.h	/^    typedef std::shared_ptr<RequestData> SP_ReqData;$/;"	t	class:TimerNode
SP_TimerNode	timer.h	/^    typedef std::shared_ptr<TimerNode> SP_TimerNode;$/;"	t	class:TimerManager
STATE_ANALYSIS	requestData.h	/^const int STATE_ANALYSIS = 4;$/;"	v
STATE_FINISH	requestData.h	/^const int STATE_FINISH = 5;$/;"	v
STATE_PARSE_HEADERS	requestData.h	/^const int STATE_PARSE_HEADERS = 2;$/;"	v
STATE_PARSE_URI	requestData.h	/^const int STATE_PARSE_URI = 1;$/;"	v
STATE_RECV_BODY	requestData.h	/^const int STATE_RECV_BODY = 3;$/;"	v
ShutDownOption	threadpool.h	/^} ShutDownOption;$/;"	t	typeref:enum:__anon1
TASK_QUEUE	main.cpp	/^const int TASK_QUEUE=65536;$/;"	v
THREADPOOL_GRACEFUL	threadpool.h	/^const int THREADPOOL_GRACEFUL = 1;$/;"	v
THREADPOOL_INVALID	threadpool.h	/^const int THREADPOOL_INVALID = -1;$/;"	v
THREADPOOL_LOCK_FAILURE	threadpool.h	/^const int THREADPOOL_LOCK_FAILURE = -2;$/;"	v
THREADPOOL_QUEUE_FULL	threadpool.h	/^const int THREADPOOL_QUEUE_FULL = -3;$/;"	v
THREADPOOL_SHUTDOWN	threadpool.h	/^const int THREADPOOL_SHUTDOWN = -4;$/;"	v
THREADPOOL_THREAD_FAILURE	threadpool.h	/^const int THREADPOOL_THREAD_FAILURE = -5;$/;"	v
THREAD_NUM	main.cpp	/^const int THREAD_NUM=4;$/;"	v
TIMER_TIME_OUT	main.cpp	/^extern const int TIMER_TIME_OUT=5000;\/\/5s$/;"	v
ThreadPool	threadpool.h	/^class ThreadPool{$/;"	c
ThreadPoolTask	threadpool.h	/^struct ThreadPoolTask{\/\/one task in task_queue$/;"	s
TimerManager	timer.h	/^class TimerManager{$/;"	c
TimerNode	timer.cpp	/^TimerNode::TimerNode(SP_ReqData rd,size_t timeout){$/;"	f	class:TimerNode
TimerNode	timer.h	/^class TimerNode{$/;"	c
TimerPriorityQueue	timer.h	/^    std::priority_queue<SP_TimerNode,std::vector<SP_TimerNode>,timerCMP> TimerPriorityQueue;$/;"	m	class:TimerManager
_CONFIG_H_	config.h	2;"	d
_EPOLL_H_	epoll.h	2;"	d
_MUTEXLOCK_H_	MutexLock.h	2;"	d
_NONCOPYABLE_H_	noncopyable.h	2;"	d
_REQUESTDATA_H_	requestData.h	2;"	d
_THREADPOOL_H_	threadpool.h	2;"	d
_TIMER_H_	timer.h	2;"	d
_UTILS_H_	utils.h	2;"	d
acceptConnection	epoll.cpp	/^void Epoll::acceptConnection(int lfd){$/;"	f	class:Epoll
addTimer	timer.cpp	/^void TimerManager::addTimer(SP_ReqData request_data,int timeout){$/;"	f	class:TimerManager
addTimer	timer.cpp	/^void TimerManager::addTimer(SP_TimerNode timer_node){$/;"	f	class:TimerManager
add_timer	epoll.cpp	/^void Epoll::add_timer(std::shared_ptr<RequestData> request_data, int timeout)$/;"	f	class:Epoll
analysisRequest	requestData.cpp	/^int RequestData::analysisRequest()$/;"	f	class:RequestData
args	threadpool.h	/^    std::shared_ptr<void> args;\/\/shi ji shang jiu shi requestdata dui xiang$/;"	m	struct:ThreadPoolTask
canRead	requestData.cpp	/^bool RequestData::canRead()$/;"	f	class:RequestData
canWrite	requestData.cpp	/^bool RequestData::canWrite()$/;"	f	class:RequestData
clearReq	timer.cpp	/^void TimerNode::clearReq(){$/;"	f	class:TimerNode
count	threadpool.cpp	/^int ThreadPool::count = 0;$/;"	m	class:ThreadPool	file:
count	threadpool.h	/^    static int count;$/;"	m	class:ThreadPool
deleted	timer.h	/^    bool deleted;\/\/should it be deleted,if true,when Timermanager::handle_expired_event() call,remove it from priority_queue $/;"	m	class:TimerNode
disableReadAndWrite	requestData.cpp	/^void RequestData::disableReadAndWrite()$/;"	f	class:RequestData
efd	epoll.cpp	/^int Epoll::efd=-1;$/;"	m	class:Epoll	file:
efd	epoll.h	/^    static int efd;$/;"	m	class:Epoll
efd	requestData.h	/^    int efd;$/;"	m	class:RequestData
enableRead	requestData.cpp	/^void RequestData::enableRead()$/;"	f	class:RequestData
enableWrite	requestData.cpp	/^void RequestData::enableWrite()$/;"	f	class:RequestData
epoll_add	epoll.cpp	/^int Epoll::epoll_add(int fd,std::shared_ptr<RequestData> request,__uint32_t events){$/;"	f	class:Epoll
epoll_del	epoll.cpp	/^int Epoll::epoll_del(int fd,__uint32_t events){$/;"	f	class:Epoll
epoll_init	epoll.cpp	/^int Epoll::epoll_init(){$/;"	f	class:Epoll
epoll_mod	epoll.cpp	/^int Epoll::epoll_mod(int fd,std::shared_ptr<RequestData> request,__uint32_t events){$/;"	f	class:Epoll
error	requestData.h	/^    bool error;$/;"	m	class:RequestData
event_v	epoll.cpp	/^std::vector<struct epoll_event> Epoll::event_v;$/;"	m	class:Epoll	file:
event_v	epoll.h	/^    static std::vector<struct epoll_event> event_v;\/\/vector of epoll_event$/;"	m	class:Epoll
events	requestData.h	/^    __uint32_t events;$/;"	m	class:RequestData
expired_time	timer.h	/^    size_t expired_time;\/\/chao shi shi ke, jue dui shi jian,expired_timedan wei hao miao $/;"	m	class:TimerNode
fd	requestData.h	/^    int fd;$/;"	m	class:RequestData
fd2reqdata_v	epoll.cpp	/^std::vector<std::shared_ptr<RequestData>> Epoll::fd2reqdata_v;$/;"	m	class:Epoll	file:
fd2reqdata_v	epoll.h	/^    static std::vector<std::shared_ptr<RequestData>> fd2reqdata_v;\/\/vector of fd->requestdata$/;"	m	class:Epoll
file_name	requestData.h	/^    std::string file_name;$/;"	m	class:RequestData
func	threadpool.h	/^    std::function<void(std::shared_ptr<void>)> func;\/\/jiu shi MyHandler() han shu$/;"	m	struct:ThreadPoolTask
getEventsRequest	epoll.cpp	/^std::vector<std::shared_ptr<RequestData>> Epoll::getEventsRequest(int lfd,int events_num){$/;"	f	class:Epoll
getExpiredTime	timer.cpp	/^size_t TimerNode::getExpiredTime()const{$/;"	f	class:TimerNode
getFd	requestData.cpp	/^int RequestData::getFd()$/;"	f	class:RequestData
getMime	requestData.cpp	/^std::string MimeType::getMime(const std::string &suffix){$/;"	f	class:MimeType
getlock	MutexLock.h	/^    pthread_mutex_t * getlock(){$/;"	f	class:MutexLock
graceful_shutdown	threadpool.h	/^    graceful_shutdown  = 2$/;"	e	enum:__anon1
h_CR	requestData.h	/^    h_CR,$/;"	e	enum:HeaderState
h_LF	requestData.h	/^    h_LF,$/;"	e	enum:HeaderState
h_colon	requestData.h	/^    h_colon,$/;"	e	enum:HeaderState
h_end_CR	requestData.h	/^    h_end_CR,$/;"	e	enum:HeaderState
h_end_LF	requestData.h	/^    h_end_LF$/;"	e	enum:HeaderState
h_key	requestData.h	/^    h_key,$/;"	e	enum:HeaderState
h_spaces_after_colon	requestData.h	/^    h_spaces_after_colon,$/;"	e	enum:HeaderState
h_start	requestData.h	/^    h_start=0,$/;"	e	enum:HeaderState
h_state	requestData.h	/^    int h_state;$/;"	m	class:RequestData
h_value	requestData.h	/^    h_value,$/;"	e	enum:HeaderState
handleConn	requestData.cpp	/^void RequestData::handleConn()$/;"	f	class:RequestData
handleError	requestData.cpp	/^void RequestData::handleError(int fd, int err_num, std::string short_msg)$/;"	f	class:RequestData
handleRead	requestData.cpp	/^void RequestData::handleRead(){$/;"	f	class:RequestData
handleWrite	requestData.cpp	/^void RequestData::handleWrite()$/;"	f	class:RequestData
handle_expired_event	timer.cpp	/^void TimerManager::handle_expired_event(){$/;"	f	class:TimerManager
handle_sigpipe	utils.cpp	/^void handle_sigpipe(){$/;"	f
head	threadpool.cpp	/^int ThreadPool::head = 0;$/;"	m	class:ThreadPool	file:
head	threadpool.h	/^    static int head;$/;"	m	class:ThreadPool
headers	requestData.h	/^    std::unordered_map<std::string, std::string> headers;$/;"	m	class:RequestData
immediate_shutdown	threadpool.h	/^    immediate_shutdown = 1,$/;"	e	enum:__anon1
inBuffer	requestData.h	/^    std::string inBuffer;$/;"	m	class:RequestData
init	requestData.cpp	/^void MimeType::init(){$/;"	f	class:MimeType
isAbleRead	requestData.h	/^    bool isAbleRead;$/;"	m	class:RequestData
isAbleWrite	requestData.h	/^    bool isAbleWrite;$/;"	m	class:RequestData
isDeleted	timer.cpp	/^bool TimerNode::isDeleted()const{$/;"	f	class:TimerNode
isfinish	requestData.h	/^    bool isfinish;$/;"	m	class:RequestData
isvalid	timer.cpp	/^bool TimerNode::isvalid(){$/;"	f	class:TimerNode
keep_alive	requestData.h	/^    bool keep_alive;$/;"	m	class:RequestData
linkTimer	requestData.cpp	/^void RequestData::linkTimer(std::shared_ptr<TimerNode> mtimer)$/;"	f	class:RequestData
lock	MutexLock.h	/^    void lock(){$/;"	f	class:MutexLock
lock	threadpool.cpp	/^pthread_mutex_t ThreadPool::lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:ThreadPool	file:
lock	threadpool.h	/^    static pthread_mutex_t lock;$/;"	m	class:ThreadPool
main	main.cpp	/^int main(){$/;"	f
method	requestData.h	/^    int method;$/;"	m	class:RequestData
mime	requestData.cpp	/^std::unordered_map<std::string, std::string> MimeType::mime;$/;"	m	class:MimeType	file:
mime	requestData.h	/^    static std::unordered_map<std::string,std::string> mime;$/;"	m	class:MimeType
mutex	MutexLock.h	/^    pthread_mutex_t mutex;$/;"	m	class:MutexLock
mutexlock	timer.h	/^    MutexLock mutexlock;\/\/this TimerManager is Critical resource,need mutex $/;"	m	class:TimerManager
my_epoll_wait	epoll.cpp	/^void Epoll::my_epoll_wait(int lfd){$/;"	f	class:Epoll
noncopyable	noncopyable.h	/^    noncopyable(){};$/;"	f	class:noncopyable
noncopyable	noncopyable.h	/^class noncopyable{$/;"	c
now_read_pos	requestData.h	/^    int now_read_pos;$/;"	m	class:RequestData
obj	makefile	/^obj=$(patsubst .\/*.cpp,.\/*.o,$(src))$/;"	m
once_control	requestData.cpp	/^pthread_once_t MimeType::once_control = PTHREAD_ONCE_INIT;$/;"	m	class:MimeType	file:
once_control	requestData.h	/^    static pthread_once_t once_control;$/;"	m	class:MimeType
operator ()	timer.h	/^    bool operator()(std::shared_ptr<TimerNode>&a,std::shared_ptr<TimerNode>&b)const{$/;"	f	struct:timerCMP
outBuffer	requestData.h	/^    std::string outBuffer;$/;"	m	class:RequestData
parse_Headers	requestData.cpp	/^int RequestData::parse_Headers()$/;"	f	class:RequestData
parse_URI	requestData.cpp	/^int RequestData::parse_URI(){$/;"	f	class:RequestData
path	requestData.h	/^    std::string path;$/;"	m	class:RequestData
queue_size	threadpool.cpp	/^int ThreadPool::queue_size = 0;$/;"	m	class:ThreadPool	file:
queue_size	threadpool.h	/^    static int queue_size;$/;"	m	class:ThreadPool
readn	utils.cpp	/^ssize_t readn(int fd,void *buf,size_t n){$/;"	f
readstr	utils.cpp	/^ssize_t readstr(int fd,std::string & inBuffer){$/;"	f
request_data	timer.h	/^    SP_ReqData request_data;\/\/pointer to this timer associate request $/;"	m	class:TimerNode
reset	requestData.cpp	/^void RequestData::reset(){$/;"	f	class:RequestData
seperateTimer	requestData.cpp	/^void RequestData::seperateTimer()$/;"	f	class:RequestData
setDeleted	timer.cpp	/^void TimerNode::setDeleted(){$/;"	f	class:TimerNode
setFd	requestData.cpp	/^void RequestData::setFd(int _fd)$/;"	f	class:RequestData
setSockNonBlocking	utils.cpp	/^int setSockNonBlocking(int fd){$/;"	f
shutdown	threadpool.cpp	/^int ThreadPool::shutdown = 0;$/;"	m	class:ThreadPool	file:
shutdown	threadpool.h	/^    static int shutdown;$/;"	m	class:ThreadPool
socket_bind_listen	main.cpp	/^int socket_bind_listen(int port){$/;"	f
src	makefile	/^src=$(wildcard .\/*.cpp)$/;"	m
started	threadpool.cpp	/^int ThreadPool::started = 0;$/;"	m	class:ThreadPool	file:
started	threadpool.h	/^    static int started;$/;"	m	class:ThreadPool
state	requestData.h	/^    int state;$/;"	m	class:RequestData
stitch	requestData.h	/^    cv::Mat stitch(cv::Mat &src){$/;"	f	class:RequestData
tail	threadpool.cpp	/^int ThreadPool::tail = 0;$/;"	m	class:ThreadPool	file:
tail	threadpool.h	/^    static int tail;$/;"	m	class:ThreadPool
target	makefile	/^target=server$/;"	m
task_queue	threadpool.cpp	/^std::vector<ThreadPoolTask> ThreadPool::task_queue;$/;"	m	class:ThreadPool	file:
task_queue	threadpool.h	/^    static std::vector<ThreadPoolTask> task_queue;$/;"	m	class:ThreadPool
task_queue_not_empty	threadpool.cpp	/^pthread_cond_t ThreadPool::task_queue_not_empty = PTHREAD_COND_INITIALIZER;$/;"	m	class:ThreadPool	file:
task_queue_not_empty	threadpool.h	/^    static pthread_cond_t task_queue_not_empty;$/;"	m	class:ThreadPool
thread_count	threadpool.cpp	/^int ThreadPool::thread_count = 0;\/\/xian cheng shu$/;"	m	class:ThreadPool	file:
thread_count	threadpool.h	/^    static int thread_count;$/;"	m	class:ThreadPool
threadpool_add_task	threadpool.cpp	/^int ThreadPool::threadpool_add_task(std::shared_ptr<void> args, std::function<void(std::shared_ptr<void>)> fun){$/;"	f	class:ThreadPool
threadpool_create	threadpool.cpp	/^int ThreadPool::threadpool_create(int _thread_count, int _queue_size){$/;"	f	class:ThreadPool
threadpool_destroy	threadpool.cpp	/^int ThreadPool::threadpool_destroy(ShutDownOption shutdown_option)$/;"	f	class:ThreadPool
threadpool_free	threadpool.cpp	/^int ThreadPool::threadpool_free()$/;"	f	class:ThreadPool
threadpool_thread	threadpool.cpp	/^void *ThreadPool::threadpool_thread(void *args)$/;"	f	class:ThreadPool
threads	threadpool.cpp	/^std::vector<pthread_t> ThreadPool::threads;$/;"	m	class:ThreadPool	file:
threads	threadpool.h	/^    static std::vector<pthread_t> threads;$/;"	m	class:ThreadPool
timer	requestData.h	/^    std::weak_ptr<TimerNode> timer;$/;"	m	class:RequestData
timerCMP	timer.h	/^struct timerCMP{\/\/func-obj,chong zai le () yunsuanfu$/;"	s
timer_manager	epoll.cpp	/^TimerManager Epoll::timer_manager;$/;"	m	class:Epoll	file:
timer_manager	epoll.h	/^    static TimerManager timer_manager;$/;"	m	class:Epoll
unlock	MutexLock.h	/^    void unlock(){$/;"	f	class:MutexLock
update	timer.cpp	/^void TimerNode::update(int timeout){$/;"	f	class:TimerNode
writen	utils.cpp	/^ssize_t writen(int fd,void * buf,size_t n){$/;"	f
writestr	utils.cpp	/^ssize_t writestr(int fd,std::string & sBuffer){$/;"	f
~MutexLock	MutexLock.h	/^    ~MutexLock(){$/;"	f	class:MutexLock
~RequestData	requestData.cpp	/^RequestData::~RequestData(){$/;"	f	class:RequestData
~TimerNode	timer.cpp	/^TimerNode::~TimerNode(){$/;"	f	class:TimerNode
~noncopyable	noncopyable.h	/^    ~noncopyable(){};$/;"	f	class:noncopyable
